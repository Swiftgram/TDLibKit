//
//  MessageContent.swift
//  tl2swift
//
//  Generated automatically. Any changes will be lost!
//  Based on TDLib 1.8.52-bc32c4b2
//  https://github.com/tdlib/td/tree/bc32c4b2
//

import Foundation


/// Contains the content of a message
public indirect enum MessageContent: Codable, Equatable, Hashable {

    /// A text message
    case messageText(MessageText)

    /// An animation message (GIF-style).
    case messageAnimation(MessageAnimation)

    /// An audio message
    case messageAudio(MessageAudio)

    /// A document message (general file)
    case messageDocument(MessageDocument)

    /// A message with paid media
    case messagePaidMedia(MessagePaidMedia)

    /// A photo message
    case messagePhoto(MessagePhoto)

    /// A sticker message
    case messageSticker(MessageSticker)

    /// A video message
    case messageVideo(MessageVideo)

    /// A video note message
    case messageVideoNote(MessageVideoNote)

    /// A voice note message
    case messageVoiceNote(MessageVoiceNote)

    /// A self-destructed photo message
    case messageExpiredPhoto

    /// A self-destructed video message
    case messageExpiredVideo

    /// A self-destructed video note message
    case messageExpiredVideoNote

    /// A self-destructed voice note message
    case messageExpiredVoiceNote

    /// A message with a location
    case messageLocation(MessageLocation)

    /// A message with information about a venue
    case messageVenue(MessageVenue)

    /// A message with a user contact
    case messageContact(MessageContact)

    /// A message with an animated emoji
    case messageAnimatedEmoji(MessageAnimatedEmoji)

    /// A dice message. The dice value is randomly generated by the server
    case messageDice(MessageDice)

    /// A message with a game
    case messageGame(MessageGame)

    /// A message with a poll
    case messagePoll(MessagePoll)

    /// A message with a forwarded story
    case messageStory(MessageStory)

    /// A message with a checklist
    case messageChecklist(MessageChecklist)

    /// A message with an invoice from a bot. Use getInternalLink with internalLinkTypeBotStart to share the invoice
    case messageInvoice(MessageInvoice)

    /// A message with information about an ended call
    case messageCall(MessageCall)

    /// A message with information about a group call not bound to a chat. If the message is incoming, the call isn't active, isn't missed, and has no duration, and getOption("can_accept_calls") is true, then incoming call screen must be shown to the user. Use getGroupCallParticipants to show current group call participants on the screen. Use joinGroupCall to accept the call or declineGroupCallInvitation to decline it. If the call become active or missed, then the call screen must be hidden
    case messageGroupCall(MessageGroupCall)

    /// A new video chat was scheduled
    case messageVideoChatScheduled(MessageVideoChatScheduled)

    /// A newly created video chat
    case messageVideoChatStarted(MessageVideoChatStarted)

    /// A message with information about an ended video chat
    case messageVideoChatEnded(MessageVideoChatEnded)

    /// A message with information about an invitation to a video chat
    case messageInviteVideoChatParticipants(MessageInviteVideoChatParticipants)

    /// A newly created basic group
    case messageBasicGroupChatCreate(MessageBasicGroupChatCreate)

    /// A newly created supergroup or channel
    case messageSupergroupChatCreate(MessageSupergroupChatCreate)

    /// An updated chat title
    case messageChatChangeTitle(MessageChatChangeTitle)

    /// An updated chat photo
    case messageChatChangePhoto(MessageChatChangePhoto)

    /// A deleted chat photo
    case messageChatDeletePhoto

    /// New chat members were added
    case messageChatAddMembers(MessageChatAddMembers)

    /// A new member joined the chat via an invite link
    case messageChatJoinByLink

    /// A new member was accepted to the chat by an administrator
    case messageChatJoinByRequest

    /// A chat member was deleted
    case messageChatDeleteMember(MessageChatDeleteMember)

    /// A basic group was upgraded to a supergroup and was deactivated as the result
    case messageChatUpgradeTo(MessageChatUpgradeTo)

    /// A supergroup has been created from a basic group
    case messageChatUpgradeFrom(MessageChatUpgradeFrom)

    /// A message has been pinned
    case messagePinMessage(MessagePinMessage)

    /// A screenshot of a message in the chat has been taken
    case messageScreenshotTaken

    /// A new background was set in the chat
    case messageChatSetBackground(MessageChatSetBackground)

    /// A theme in the chat has been changed
    case messageChatSetTheme(MessageChatSetTheme)

    /// The auto-delete or self-destruct timer for messages in the chat has been changed
    case messageChatSetMessageAutoDeleteTime(MessageChatSetMessageAutoDeleteTime)

    /// The chat was boosted by the sender of the message
    case messageChatBoost(MessageChatBoost)

    /// A forum topic has been created
    case messageForumTopicCreated(MessageForumTopicCreated)

    /// A forum topic has been edited
    case messageForumTopicEdited(MessageForumTopicEdited)

    /// A forum topic has been closed or opened
    case messageForumTopicIsClosedToggled(MessageForumTopicIsClosedToggled)

    /// A General forum topic has been hidden or unhidden
    case messageForumTopicIsHiddenToggled(MessageForumTopicIsHiddenToggled)

    /// A profile photo was suggested to a user in a private chat
    case messageSuggestProfilePhoto(MessageSuggestProfilePhoto)

    /// A non-standard action has happened in the chat
    case messageCustomServiceAction(MessageCustomServiceAction)

    /// A new high score was achieved in a game
    case messageGameScore(MessageGameScore)

    /// A payment has been sent to a bot or a business account
    case messagePaymentSuccessful(MessagePaymentSuccessful)

    /// A payment has been received by the bot or the business account
    case messagePaymentSuccessfulBot(MessagePaymentSuccessfulBot)

    /// A payment has been refunded
    case messagePaymentRefunded(MessagePaymentRefunded)

    /// Telegram Premium was gifted to a user
    case messageGiftedPremium(MessageGiftedPremium)

    /// A Telegram Premium gift code was created for the user
    case messagePremiumGiftCode(MessagePremiumGiftCode)

    /// A giveaway was created for the chat. Use telegramPaymentPurposePremiumGiveaway, storePaymentPurposePremiumGiveaway, telegramPaymentPurposeStarGiveaway, or storePaymentPurposeStarGiveaway to create a giveaway
    case messageGiveawayCreated(MessageGiveawayCreated)

    /// A giveaway
    case messageGiveaway(MessageGiveaway)

    /// A giveaway without public winners has been completed for the chat
    case messageGiveawayCompleted(MessageGiveawayCompleted)

    /// A giveaway with public winners has been completed for the chat
    case messageGiveawayWinners(MessageGiveawayWinners)

    /// Telegram Stars were gifted to a user
    case messageGiftedStars(MessageGiftedStars)

    /// Toncoins were gifted to a user
    case messageGiftedTon(MessageGiftedTon)

    /// A Telegram Stars were received by the current user from a giveaway
    case messageGiveawayPrizeStars(MessageGiveawayPrizeStars)

    /// A regular gift was received or sent by the current user, or the current user was notified about a channel gift
    case messageGift(MessageGift)

    /// An upgraded gift was received or sent by the current user, or the current user was notified about a channel gift
    case messageUpgradedGift(MessageUpgradedGift)

    /// A gift which purchase, upgrade or transfer were refunded
    case messageRefundedUpgradedGift(MessageRefundedUpgradedGift)

    /// Paid messages were refunded
    case messagePaidMessagesRefunded(MessagePaidMessagesRefunded)

    /// A price for paid messages was changed in the supergroup chat
    case messagePaidMessagePriceChanged(MessagePaidMessagePriceChanged)

    /// A price for direct messages was changed in the channel chat
    case messageDirectMessagePriceChanged(MessageDirectMessagePriceChanged)

    /// Some tasks from a checklist were marked as done or not done
    case messageChecklistTasksDone(MessageChecklistTasksDone)

    /// Some tasks were added to a checklist
    case messageChecklistTasksAdded(MessageChecklistTasksAdded)

    /// Approval of suggested post has failed, because the user which proposed the post had no enough funds
    case messageSuggestedPostApprovalFailed(MessageSuggestedPostApprovalFailed)

    /// A suggested post was approved
    case messageSuggestedPostApproved(MessageSuggestedPostApproved)

    /// A suggested post was declined
    case messageSuggestedPostDeclined(MessageSuggestedPostDeclined)

    /// A suggested post was published for getOption("suggested_post_lifetime_min") seconds and payment for the post was received
    case messageSuggestedPostPaid(MessageSuggestedPostPaid)

    /// A suggested post was refunded
    case messageSuggestedPostRefunded(MessageSuggestedPostRefunded)

    /// A contact has registered with Telegram
    case messageContactRegistered

    /// The current user shared users, which were requested by the bot
    case messageUsersShared(MessageUsersShared)

    /// The current user shared a chat, which was requested by the bot
    case messageChatShared(MessageChatShared)

    /// The user allowed the bot to send messages
    case messageBotWriteAccessAllowed(MessageBotWriteAccessAllowed)

    /// Data from a Web App has been sent to a bot
    case messageWebAppDataSent(MessageWebAppDataSent)

    /// Data from a Web App has been received; for bots only
    case messageWebAppDataReceived(MessageWebAppDataReceived)

    /// Telegram Passport data has been sent to a bot
    case messagePassportDataSent(MessagePassportDataSent)

    /// Telegram Passport data has been received; for bots only
    case messagePassportDataReceived(MessagePassportDataReceived)

    /// A user in the chat came within proximity alert range
    case messageProximityAlertTriggered(MessageProximityAlertTriggered)

    /// A message content that is not supported in the current TDLib version
    case messageUnsupported


    private enum Kind: String, Codable {
        case messageText
        case messageAnimation
        case messageAudio
        case messageDocument
        case messagePaidMedia
        case messagePhoto
        case messageSticker
        case messageVideo
        case messageVideoNote
        case messageVoiceNote
        case messageExpiredPhoto
        case messageExpiredVideo
        case messageExpiredVideoNote
        case messageExpiredVoiceNote
        case messageLocation
        case messageVenue
        case messageContact
        case messageAnimatedEmoji
        case messageDice
        case messageGame
        case messagePoll
        case messageStory
        case messageChecklist
        case messageInvoice
        case messageCall
        case messageGroupCall
        case messageVideoChatScheduled
        case messageVideoChatStarted
        case messageVideoChatEnded
        case messageInviteVideoChatParticipants
        case messageBasicGroupChatCreate
        case messageSupergroupChatCreate
        case messageChatChangeTitle
        case messageChatChangePhoto
        case messageChatDeletePhoto
        case messageChatAddMembers
        case messageChatJoinByLink
        case messageChatJoinByRequest
        case messageChatDeleteMember
        case messageChatUpgradeTo
        case messageChatUpgradeFrom
        case messagePinMessage
        case messageScreenshotTaken
        case messageChatSetBackground
        case messageChatSetTheme
        case messageChatSetMessageAutoDeleteTime
        case messageChatBoost
        case messageForumTopicCreated
        case messageForumTopicEdited
        case messageForumTopicIsClosedToggled
        case messageForumTopicIsHiddenToggled
        case messageSuggestProfilePhoto
        case messageCustomServiceAction
        case messageGameScore
        case messagePaymentSuccessful
        case messagePaymentSuccessfulBot
        case messagePaymentRefunded
        case messageGiftedPremium
        case messagePremiumGiftCode
        case messageGiveawayCreated
        case messageGiveaway
        case messageGiveawayCompleted
        case messageGiveawayWinners
        case messageGiftedStars
        case messageGiftedTon
        case messageGiveawayPrizeStars
        case messageGift
        case messageUpgradedGift
        case messageRefundedUpgradedGift
        case messagePaidMessagesRefunded
        case messagePaidMessagePriceChanged
        case messageDirectMessagePriceChanged
        case messageChecklistTasksDone
        case messageChecklistTasksAdded
        case messageSuggestedPostApprovalFailed
        case messageSuggestedPostApproved
        case messageSuggestedPostDeclined
        case messageSuggestedPostPaid
        case messageSuggestedPostRefunded
        case messageContactRegistered
        case messageUsersShared
        case messageChatShared
        case messageBotWriteAccessAllowed
        case messageWebAppDataSent
        case messageWebAppDataReceived
        case messagePassportDataSent
        case messagePassportDataReceived
        case messageProximityAlertTriggered
        case messageUnsupported
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: DtoCodingKeys.self)
        let type = try container.decode(Kind.self, forKey: .type)
        switch type {
        case .messageText:
            let value = try MessageText(from: decoder)
            self = .messageText(value)
        case .messageAnimation:
            let value = try MessageAnimation(from: decoder)
            self = .messageAnimation(value)
        case .messageAudio:
            let value = try MessageAudio(from: decoder)
            self = .messageAudio(value)
        case .messageDocument:
            let value = try MessageDocument(from: decoder)
            self = .messageDocument(value)
        case .messagePaidMedia:
            let value = try MessagePaidMedia(from: decoder)
            self = .messagePaidMedia(value)
        case .messagePhoto:
            let value = try MessagePhoto(from: decoder)
            self = .messagePhoto(value)
        case .messageSticker:
            let value = try MessageSticker(from: decoder)
            self = .messageSticker(value)
        case .messageVideo:
            let value = try MessageVideo(from: decoder)
            self = .messageVideo(value)
        case .messageVideoNote:
            let value = try MessageVideoNote(from: decoder)
            self = .messageVideoNote(value)
        case .messageVoiceNote:
            let value = try MessageVoiceNote(from: decoder)
            self = .messageVoiceNote(value)
        case .messageExpiredPhoto:
            self = .messageExpiredPhoto
        case .messageExpiredVideo:
            self = .messageExpiredVideo
        case .messageExpiredVideoNote:
            self = .messageExpiredVideoNote
        case .messageExpiredVoiceNote:
            self = .messageExpiredVoiceNote
        case .messageLocation:
            let value = try MessageLocation(from: decoder)
            self = .messageLocation(value)
        case .messageVenue:
            let value = try MessageVenue(from: decoder)
            self = .messageVenue(value)
        case .messageContact:
            let value = try MessageContact(from: decoder)
            self = .messageContact(value)
        case .messageAnimatedEmoji:
            let value = try MessageAnimatedEmoji(from: decoder)
            self = .messageAnimatedEmoji(value)
        case .messageDice:
            let value = try MessageDice(from: decoder)
            self = .messageDice(value)
        case .messageGame:
            let value = try MessageGame(from: decoder)
            self = .messageGame(value)
        case .messagePoll:
            let value = try MessagePoll(from: decoder)
            self = .messagePoll(value)
        case .messageStory:
            let value = try MessageStory(from: decoder)
            self = .messageStory(value)
        case .messageChecklist:
            let value = try MessageChecklist(from: decoder)
            self = .messageChecklist(value)
        case .messageInvoice:
            let value = try MessageInvoice(from: decoder)
            self = .messageInvoice(value)
        case .messageCall:
            let value = try MessageCall(from: decoder)
            self = .messageCall(value)
        case .messageGroupCall:
            let value = try MessageGroupCall(from: decoder)
            self = .messageGroupCall(value)
        case .messageVideoChatScheduled:
            let value = try MessageVideoChatScheduled(from: decoder)
            self = .messageVideoChatScheduled(value)
        case .messageVideoChatStarted:
            let value = try MessageVideoChatStarted(from: decoder)
            self = .messageVideoChatStarted(value)
        case .messageVideoChatEnded:
            let value = try MessageVideoChatEnded(from: decoder)
            self = .messageVideoChatEnded(value)
        case .messageInviteVideoChatParticipants:
            let value = try MessageInviteVideoChatParticipants(from: decoder)
            self = .messageInviteVideoChatParticipants(value)
        case .messageBasicGroupChatCreate:
            let value = try MessageBasicGroupChatCreate(from: decoder)
            self = .messageBasicGroupChatCreate(value)
        case .messageSupergroupChatCreate:
            let value = try MessageSupergroupChatCreate(from: decoder)
            self = .messageSupergroupChatCreate(value)
        case .messageChatChangeTitle:
            let value = try MessageChatChangeTitle(from: decoder)
            self = .messageChatChangeTitle(value)
        case .messageChatChangePhoto:
            let value = try MessageChatChangePhoto(from: decoder)
            self = .messageChatChangePhoto(value)
        case .messageChatDeletePhoto:
            self = .messageChatDeletePhoto
        case .messageChatAddMembers:
            let value = try MessageChatAddMembers(from: decoder)
            self = .messageChatAddMembers(value)
        case .messageChatJoinByLink:
            self = .messageChatJoinByLink
        case .messageChatJoinByRequest:
            self = .messageChatJoinByRequest
        case .messageChatDeleteMember:
            let value = try MessageChatDeleteMember(from: decoder)
            self = .messageChatDeleteMember(value)
        case .messageChatUpgradeTo:
            let value = try MessageChatUpgradeTo(from: decoder)
            self = .messageChatUpgradeTo(value)
        case .messageChatUpgradeFrom:
            let value = try MessageChatUpgradeFrom(from: decoder)
            self = .messageChatUpgradeFrom(value)
        case .messagePinMessage:
            let value = try MessagePinMessage(from: decoder)
            self = .messagePinMessage(value)
        case .messageScreenshotTaken:
            self = .messageScreenshotTaken
        case .messageChatSetBackground:
            let value = try MessageChatSetBackground(from: decoder)
            self = .messageChatSetBackground(value)
        case .messageChatSetTheme:
            let value = try MessageChatSetTheme(from: decoder)
            self = .messageChatSetTheme(value)
        case .messageChatSetMessageAutoDeleteTime:
            let value = try MessageChatSetMessageAutoDeleteTime(from: decoder)
            self = .messageChatSetMessageAutoDeleteTime(value)
        case .messageChatBoost:
            let value = try MessageChatBoost(from: decoder)
            self = .messageChatBoost(value)
        case .messageForumTopicCreated:
            let value = try MessageForumTopicCreated(from: decoder)
            self = .messageForumTopicCreated(value)
        case .messageForumTopicEdited:
            let value = try MessageForumTopicEdited(from: decoder)
            self = .messageForumTopicEdited(value)
        case .messageForumTopicIsClosedToggled:
            let value = try MessageForumTopicIsClosedToggled(from: decoder)
            self = .messageForumTopicIsClosedToggled(value)
        case .messageForumTopicIsHiddenToggled:
            let value = try MessageForumTopicIsHiddenToggled(from: decoder)
            self = .messageForumTopicIsHiddenToggled(value)
        case .messageSuggestProfilePhoto:
            let value = try MessageSuggestProfilePhoto(from: decoder)
            self = .messageSuggestProfilePhoto(value)
        case .messageCustomServiceAction:
            let value = try MessageCustomServiceAction(from: decoder)
            self = .messageCustomServiceAction(value)
        case .messageGameScore:
            let value = try MessageGameScore(from: decoder)
            self = .messageGameScore(value)
        case .messagePaymentSuccessful:
            let value = try MessagePaymentSuccessful(from: decoder)
            self = .messagePaymentSuccessful(value)
        case .messagePaymentSuccessfulBot:
            let value = try MessagePaymentSuccessfulBot(from: decoder)
            self = .messagePaymentSuccessfulBot(value)
        case .messagePaymentRefunded:
            let value = try MessagePaymentRefunded(from: decoder)
            self = .messagePaymentRefunded(value)
        case .messageGiftedPremium:
            let value = try MessageGiftedPremium(from: decoder)
            self = .messageGiftedPremium(value)
        case .messagePremiumGiftCode:
            let value = try MessagePremiumGiftCode(from: decoder)
            self = .messagePremiumGiftCode(value)
        case .messageGiveawayCreated:
            let value = try MessageGiveawayCreated(from: decoder)
            self = .messageGiveawayCreated(value)
        case .messageGiveaway:
            let value = try MessageGiveaway(from: decoder)
            self = .messageGiveaway(value)
        case .messageGiveawayCompleted:
            let value = try MessageGiveawayCompleted(from: decoder)
            self = .messageGiveawayCompleted(value)
        case .messageGiveawayWinners:
            let value = try MessageGiveawayWinners(from: decoder)
            self = .messageGiveawayWinners(value)
        case .messageGiftedStars:
            let value = try MessageGiftedStars(from: decoder)
            self = .messageGiftedStars(value)
        case .messageGiftedTon:
            let value = try MessageGiftedTon(from: decoder)
            self = .messageGiftedTon(value)
        case .messageGiveawayPrizeStars:
            let value = try MessageGiveawayPrizeStars(from: decoder)
            self = .messageGiveawayPrizeStars(value)
        case .messageGift:
            let value = try MessageGift(from: decoder)
            self = .messageGift(value)
        case .messageUpgradedGift:
            let value = try MessageUpgradedGift(from: decoder)
            self = .messageUpgradedGift(value)
        case .messageRefundedUpgradedGift:
            let value = try MessageRefundedUpgradedGift(from: decoder)
            self = .messageRefundedUpgradedGift(value)
        case .messagePaidMessagesRefunded:
            let value = try MessagePaidMessagesRefunded(from: decoder)
            self = .messagePaidMessagesRefunded(value)
        case .messagePaidMessagePriceChanged:
            let value = try MessagePaidMessagePriceChanged(from: decoder)
            self = .messagePaidMessagePriceChanged(value)
        case .messageDirectMessagePriceChanged:
            let value = try MessageDirectMessagePriceChanged(from: decoder)
            self = .messageDirectMessagePriceChanged(value)
        case .messageChecklistTasksDone:
            let value = try MessageChecklistTasksDone(from: decoder)
            self = .messageChecklistTasksDone(value)
        case .messageChecklistTasksAdded:
            let value = try MessageChecklistTasksAdded(from: decoder)
            self = .messageChecklistTasksAdded(value)
        case .messageSuggestedPostApprovalFailed:
            let value = try MessageSuggestedPostApprovalFailed(from: decoder)
            self = .messageSuggestedPostApprovalFailed(value)
        case .messageSuggestedPostApproved:
            let value = try MessageSuggestedPostApproved(from: decoder)
            self = .messageSuggestedPostApproved(value)
        case .messageSuggestedPostDeclined:
            let value = try MessageSuggestedPostDeclined(from: decoder)
            self = .messageSuggestedPostDeclined(value)
        case .messageSuggestedPostPaid:
            let value = try MessageSuggestedPostPaid(from: decoder)
            self = .messageSuggestedPostPaid(value)
        case .messageSuggestedPostRefunded:
            let value = try MessageSuggestedPostRefunded(from: decoder)
            self = .messageSuggestedPostRefunded(value)
        case .messageContactRegistered:
            self = .messageContactRegistered
        case .messageUsersShared:
            let value = try MessageUsersShared(from: decoder)
            self = .messageUsersShared(value)
        case .messageChatShared:
            let value = try MessageChatShared(from: decoder)
            self = .messageChatShared(value)
        case .messageBotWriteAccessAllowed:
            let value = try MessageBotWriteAccessAllowed(from: decoder)
            self = .messageBotWriteAccessAllowed(value)
        case .messageWebAppDataSent:
            let value = try MessageWebAppDataSent(from: decoder)
            self = .messageWebAppDataSent(value)
        case .messageWebAppDataReceived:
            let value = try MessageWebAppDataReceived(from: decoder)
            self = .messageWebAppDataReceived(value)
        case .messagePassportDataSent:
            let value = try MessagePassportDataSent(from: decoder)
            self = .messagePassportDataSent(value)
        case .messagePassportDataReceived:
            let value = try MessagePassportDataReceived(from: decoder)
            self = .messagePassportDataReceived(value)
        case .messageProximityAlertTriggered:
            let value = try MessageProximityAlertTriggered(from: decoder)
            self = .messageProximityAlertTriggered(value)
        case .messageUnsupported:
            self = .messageUnsupported
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: DtoCodingKeys.self)
        switch self {
        case .messageText(let value):
            try container.encode(Kind.messageText, forKey: .type)
            try value.encode(to: encoder)
        case .messageAnimation(let value):
            try container.encode(Kind.messageAnimation, forKey: .type)
            try value.encode(to: encoder)
        case .messageAudio(let value):
            try container.encode(Kind.messageAudio, forKey: .type)
            try value.encode(to: encoder)
        case .messageDocument(let value):
            try container.encode(Kind.messageDocument, forKey: .type)
            try value.encode(to: encoder)
        case .messagePaidMedia(let value):
            try container.encode(Kind.messagePaidMedia, forKey: .type)
            try value.encode(to: encoder)
        case .messagePhoto(let value):
            try container.encode(Kind.messagePhoto, forKey: .type)
            try value.encode(to: encoder)
        case .messageSticker(let value):
            try container.encode(Kind.messageSticker, forKey: .type)
            try value.encode(to: encoder)
        case .messageVideo(let value):
            try container.encode(Kind.messageVideo, forKey: .type)
            try value.encode(to: encoder)
        case .messageVideoNote(let value):
            try container.encode(Kind.messageVideoNote, forKey: .type)
            try value.encode(to: encoder)
        case .messageVoiceNote(let value):
            try container.encode(Kind.messageVoiceNote, forKey: .type)
            try value.encode(to: encoder)
        case .messageExpiredPhoto:
            try container.encode(Kind.messageExpiredPhoto, forKey: .type)
        case .messageExpiredVideo:
            try container.encode(Kind.messageExpiredVideo, forKey: .type)
        case .messageExpiredVideoNote:
            try container.encode(Kind.messageExpiredVideoNote, forKey: .type)
        case .messageExpiredVoiceNote:
            try container.encode(Kind.messageExpiredVoiceNote, forKey: .type)
        case .messageLocation(let value):
            try container.encode(Kind.messageLocation, forKey: .type)
            try value.encode(to: encoder)
        case .messageVenue(let value):
            try container.encode(Kind.messageVenue, forKey: .type)
            try value.encode(to: encoder)
        case .messageContact(let value):
            try container.encode(Kind.messageContact, forKey: .type)
            try value.encode(to: encoder)
        case .messageAnimatedEmoji(let value):
            try container.encode(Kind.messageAnimatedEmoji, forKey: .type)
            try value.encode(to: encoder)
        case .messageDice(let value):
            try container.encode(Kind.messageDice, forKey: .type)
            try value.encode(to: encoder)
        case .messageGame(let value):
            try container.encode(Kind.messageGame, forKey: .type)
            try value.encode(to: encoder)
        case .messagePoll(let value):
            try container.encode(Kind.messagePoll, forKey: .type)
            try value.encode(to: encoder)
        case .messageStory(let value):
            try container.encode(Kind.messageStory, forKey: .type)
            try value.encode(to: encoder)
        case .messageChecklist(let value):
            try container.encode(Kind.messageChecklist, forKey: .type)
            try value.encode(to: encoder)
        case .messageInvoice(let value):
            try container.encode(Kind.messageInvoice, forKey: .type)
            try value.encode(to: encoder)
        case .messageCall(let value):
            try container.encode(Kind.messageCall, forKey: .type)
            try value.encode(to: encoder)
        case .messageGroupCall(let value):
            try container.encode(Kind.messageGroupCall, forKey: .type)
            try value.encode(to: encoder)
        case .messageVideoChatScheduled(let value):
            try container.encode(Kind.messageVideoChatScheduled, forKey: .type)
            try value.encode(to: encoder)
        case .messageVideoChatStarted(let value):
            try container.encode(Kind.messageVideoChatStarted, forKey: .type)
            try value.encode(to: encoder)
        case .messageVideoChatEnded(let value):
            try container.encode(Kind.messageVideoChatEnded, forKey: .type)
            try value.encode(to: encoder)
        case .messageInviteVideoChatParticipants(let value):
            try container.encode(Kind.messageInviteVideoChatParticipants, forKey: .type)
            try value.encode(to: encoder)
        case .messageBasicGroupChatCreate(let value):
            try container.encode(Kind.messageBasicGroupChatCreate, forKey: .type)
            try value.encode(to: encoder)
        case .messageSupergroupChatCreate(let value):
            try container.encode(Kind.messageSupergroupChatCreate, forKey: .type)
            try value.encode(to: encoder)
        case .messageChatChangeTitle(let value):
            try container.encode(Kind.messageChatChangeTitle, forKey: .type)
            try value.encode(to: encoder)
        case .messageChatChangePhoto(let value):
            try container.encode(Kind.messageChatChangePhoto, forKey: .type)
            try value.encode(to: encoder)
        case .messageChatDeletePhoto:
            try container.encode(Kind.messageChatDeletePhoto, forKey: .type)
        case .messageChatAddMembers(let value):
            try container.encode(Kind.messageChatAddMembers, forKey: .type)
            try value.encode(to: encoder)
        case .messageChatJoinByLink:
            try container.encode(Kind.messageChatJoinByLink, forKey: .type)
        case .messageChatJoinByRequest:
            try container.encode(Kind.messageChatJoinByRequest, forKey: .type)
        case .messageChatDeleteMember(let value):
            try container.encode(Kind.messageChatDeleteMember, forKey: .type)
            try value.encode(to: encoder)
        case .messageChatUpgradeTo(let value):
            try container.encode(Kind.messageChatUpgradeTo, forKey: .type)
            try value.encode(to: encoder)
        case .messageChatUpgradeFrom(let value):
            try container.encode(Kind.messageChatUpgradeFrom, forKey: .type)
            try value.encode(to: encoder)
        case .messagePinMessage(let value):
            try container.encode(Kind.messagePinMessage, forKey: .type)
            try value.encode(to: encoder)
        case .messageScreenshotTaken:
            try container.encode(Kind.messageScreenshotTaken, forKey: .type)
        case .messageChatSetBackground(let value):
            try container.encode(Kind.messageChatSetBackground, forKey: .type)
            try value.encode(to: encoder)
        case .messageChatSetTheme(let value):
            try container.encode(Kind.messageChatSetTheme, forKey: .type)
            try value.encode(to: encoder)
        case .messageChatSetMessageAutoDeleteTime(let value):
            try container.encode(Kind.messageChatSetMessageAutoDeleteTime, forKey: .type)
            try value.encode(to: encoder)
        case .messageChatBoost(let value):
            try container.encode(Kind.messageChatBoost, forKey: .type)
            try value.encode(to: encoder)
        case .messageForumTopicCreated(let value):
            try container.encode(Kind.messageForumTopicCreated, forKey: .type)
            try value.encode(to: encoder)
        case .messageForumTopicEdited(let value):
            try container.encode(Kind.messageForumTopicEdited, forKey: .type)
            try value.encode(to: encoder)
        case .messageForumTopicIsClosedToggled(let value):
            try container.encode(Kind.messageForumTopicIsClosedToggled, forKey: .type)
            try value.encode(to: encoder)
        case .messageForumTopicIsHiddenToggled(let value):
            try container.encode(Kind.messageForumTopicIsHiddenToggled, forKey: .type)
            try value.encode(to: encoder)
        case .messageSuggestProfilePhoto(let value):
            try container.encode(Kind.messageSuggestProfilePhoto, forKey: .type)
            try value.encode(to: encoder)
        case .messageCustomServiceAction(let value):
            try container.encode(Kind.messageCustomServiceAction, forKey: .type)
            try value.encode(to: encoder)
        case .messageGameScore(let value):
            try container.encode(Kind.messageGameScore, forKey: .type)
            try value.encode(to: encoder)
        case .messagePaymentSuccessful(let value):
            try container.encode(Kind.messagePaymentSuccessful, forKey: .type)
            try value.encode(to: encoder)
        case .messagePaymentSuccessfulBot(let value):
            try container.encode(Kind.messagePaymentSuccessfulBot, forKey: .type)
            try value.encode(to: encoder)
        case .messagePaymentRefunded(let value):
            try container.encode(Kind.messagePaymentRefunded, forKey: .type)
            try value.encode(to: encoder)
        case .messageGiftedPremium(let value):
            try container.encode(Kind.messageGiftedPremium, forKey: .type)
            try value.encode(to: encoder)
        case .messagePremiumGiftCode(let value):
            try container.encode(Kind.messagePremiumGiftCode, forKey: .type)
            try value.encode(to: encoder)
        case .messageGiveawayCreated(let value):
            try container.encode(Kind.messageGiveawayCreated, forKey: .type)
            try value.encode(to: encoder)
        case .messageGiveaway(let value):
            try container.encode(Kind.messageGiveaway, forKey: .type)
            try value.encode(to: encoder)
        case .messageGiveawayCompleted(let value):
            try container.encode(Kind.messageGiveawayCompleted, forKey: .type)
            try value.encode(to: encoder)
        case .messageGiveawayWinners(let value):
            try container.encode(Kind.messageGiveawayWinners, forKey: .type)
            try value.encode(to: encoder)
        case .messageGiftedStars(let value):
            try container.encode(Kind.messageGiftedStars, forKey: .type)
            try value.encode(to: encoder)
        case .messageGiftedTon(let value):
            try container.encode(Kind.messageGiftedTon, forKey: .type)
            try value.encode(to: encoder)
        case .messageGiveawayPrizeStars(let value):
            try container.encode(Kind.messageGiveawayPrizeStars, forKey: .type)
            try value.encode(to: encoder)
        case .messageGift(let value):
            try container.encode(Kind.messageGift, forKey: .type)
            try value.encode(to: encoder)
        case .messageUpgradedGift(let value):
            try container.encode(Kind.messageUpgradedGift, forKey: .type)
            try value.encode(to: encoder)
        case .messageRefundedUpgradedGift(let value):
            try container.encode(Kind.messageRefundedUpgradedGift, forKey: .type)
            try value.encode(to: encoder)
        case .messagePaidMessagesRefunded(let value):
            try container.encode(Kind.messagePaidMessagesRefunded, forKey: .type)
            try value.encode(to: encoder)
        case .messagePaidMessagePriceChanged(let value):
            try container.encode(Kind.messagePaidMessagePriceChanged, forKey: .type)
            try value.encode(to: encoder)
        case .messageDirectMessagePriceChanged(let value):
            try container.encode(Kind.messageDirectMessagePriceChanged, forKey: .type)
            try value.encode(to: encoder)
        case .messageChecklistTasksDone(let value):
            try container.encode(Kind.messageChecklistTasksDone, forKey: .type)
            try value.encode(to: encoder)
        case .messageChecklistTasksAdded(let value):
            try container.encode(Kind.messageChecklistTasksAdded, forKey: .type)
            try value.encode(to: encoder)
        case .messageSuggestedPostApprovalFailed(let value):
            try container.encode(Kind.messageSuggestedPostApprovalFailed, forKey: .type)
            try value.encode(to: encoder)
        case .messageSuggestedPostApproved(let value):
            try container.encode(Kind.messageSuggestedPostApproved, forKey: .type)
            try value.encode(to: encoder)
        case .messageSuggestedPostDeclined(let value):
            try container.encode(Kind.messageSuggestedPostDeclined, forKey: .type)
            try value.encode(to: encoder)
        case .messageSuggestedPostPaid(let value):
            try container.encode(Kind.messageSuggestedPostPaid, forKey: .type)
            try value.encode(to: encoder)
        case .messageSuggestedPostRefunded(let value):
            try container.encode(Kind.messageSuggestedPostRefunded, forKey: .type)
            try value.encode(to: encoder)
        case .messageContactRegistered:
            try container.encode(Kind.messageContactRegistered, forKey: .type)
        case .messageUsersShared(let value):
            try container.encode(Kind.messageUsersShared, forKey: .type)
            try value.encode(to: encoder)
        case .messageChatShared(let value):
            try container.encode(Kind.messageChatShared, forKey: .type)
            try value.encode(to: encoder)
        case .messageBotWriteAccessAllowed(let value):
            try container.encode(Kind.messageBotWriteAccessAllowed, forKey: .type)
            try value.encode(to: encoder)
        case .messageWebAppDataSent(let value):
            try container.encode(Kind.messageWebAppDataSent, forKey: .type)
            try value.encode(to: encoder)
        case .messageWebAppDataReceived(let value):
            try container.encode(Kind.messageWebAppDataReceived, forKey: .type)
            try value.encode(to: encoder)
        case .messagePassportDataSent(let value):
            try container.encode(Kind.messagePassportDataSent, forKey: .type)
            try value.encode(to: encoder)
        case .messagePassportDataReceived(let value):
            try container.encode(Kind.messagePassportDataReceived, forKey: .type)
            try value.encode(to: encoder)
        case .messageProximityAlertTriggered(let value):
            try container.encode(Kind.messageProximityAlertTriggered, forKey: .type)
            try value.encode(to: encoder)
        case .messageUnsupported:
            try container.encode(Kind.messageUnsupported, forKey: .type)
        }
    }
}

/// A text message
public struct MessageText: Codable, Equatable, Hashable {

    /// A link preview attached to the message; may be null
    public let linkPreview: LinkPreview?

    /// Options which were used for generation of the link preview; may be null if default options were used
    public let linkPreviewOptions: LinkPreviewOptions?

    /// Text of the message
    public let text: FormattedText


    public init(
        linkPreview: LinkPreview?,
        linkPreviewOptions: LinkPreviewOptions?,
        text: FormattedText
    ) {
        self.linkPreview = linkPreview
        self.linkPreviewOptions = linkPreviewOptions
        self.text = text
    }
}

/// An animation message (GIF-style).
public struct MessageAnimation: Codable, Equatable, Hashable {

    /// The animation description
    public let animation: Animation

    /// Animation caption
    public let caption: FormattedText

    /// True, if the animation preview must be covered by a spoiler animation
    public let hasSpoiler: Bool

    /// True, if the animation thumbnail must be blurred and the animation must be shown only while tapped
    public let isSecret: Bool

    /// True, if the caption must be shown above the animation; otherwise, the caption must be shown below the animation
    public let showCaptionAboveMedia: Bool


    public init(
        animation: Animation,
        caption: FormattedText,
        hasSpoiler: Bool,
        isSecret: Bool,
        showCaptionAboveMedia: Bool
    ) {
        self.animation = animation
        self.caption = caption
        self.hasSpoiler = hasSpoiler
        self.isSecret = isSecret
        self.showCaptionAboveMedia = showCaptionAboveMedia
    }
}

/// An audio message
public struct MessageAudio: Codable, Equatable, Hashable {

    /// The audio description
    public let audio: Audio

    /// Audio caption
    public let caption: FormattedText


    public init(
        audio: Audio,
        caption: FormattedText
    ) {
        self.audio = audio
        self.caption = caption
    }
}

/// A document message (general file)
public struct MessageDocument: Codable, Equatable, Hashable {

    /// Document caption
    public let caption: FormattedText

    /// The document description
    public let document: Document


    public init(
        caption: FormattedText,
        document: Document
    ) {
        self.caption = caption
        self.document = document
    }
}

/// A message with paid media
public struct MessagePaidMedia: Codable, Equatable, Hashable {

    /// Media caption
    public let caption: FormattedText

    /// Information about the media
    public let media: [PaidMedia]

    /// True, if the caption must be shown above the media; otherwise, the caption must be shown below the media
    public let showCaptionAboveMedia: Bool

    /// Number of Telegram Stars needed to buy access to the media in the message
    public let starCount: Int64


    public init(
        caption: FormattedText,
        media: [PaidMedia],
        showCaptionAboveMedia: Bool,
        starCount: Int64
    ) {
        self.caption = caption
        self.media = media
        self.showCaptionAboveMedia = showCaptionAboveMedia
        self.starCount = starCount
    }
}

/// A photo message
public struct MessagePhoto: Codable, Equatable, Hashable {

    /// Photo caption
    public let caption: FormattedText

    /// True, if the photo preview must be covered by a spoiler animation
    public let hasSpoiler: Bool

    /// True, if the photo must be blurred and must be shown only while tapped
    public let isSecret: Bool

    /// The photo
    public let photo: Photo

    /// True, if the caption must be shown above the photo; otherwise, the caption must be shown below the photo
    public let showCaptionAboveMedia: Bool


    public init(
        caption: FormattedText,
        hasSpoiler: Bool,
        isSecret: Bool,
        photo: Photo,
        showCaptionAboveMedia: Bool
    ) {
        self.caption = caption
        self.hasSpoiler = hasSpoiler
        self.isSecret = isSecret
        self.photo = photo
        self.showCaptionAboveMedia = showCaptionAboveMedia
    }
}

/// A sticker message
public struct MessageSticker: Codable, Equatable, Hashable {

    /// True, if premium animation of the sticker must be played
    public let isPremium: Bool

    /// The sticker description
    public let sticker: Sticker


    public init(
        isPremium: Bool,
        sticker: Sticker
    ) {
        self.isPremium = isPremium
        self.sticker = sticker
    }
}

/// A video message
public struct MessageVideo: Codable, Equatable, Hashable {

    /// Alternative qualities of the video
    public let alternativeVideos: [AlternativeVideo]

    /// Video caption
    public let caption: FormattedText

    /// Cover of the video; may be null if none
    public let cover: Photo?

    /// True, if the video preview must be covered by a spoiler animation
    public let hasSpoiler: Bool

    /// True, if the video thumbnail must be blurred and the video must be shown only while tapped
    public let isSecret: Bool

    /// True, if the caption must be shown above the video; otherwise, the caption must be shown below the video
    public let showCaptionAboveMedia: Bool

    /// Timestamp from which the video playing must start, in seconds
    public let startTimestamp: Int

    /// Available storyboards for the video
    public let storyboards: [VideoStoryboard]

    /// The video description
    public let video: Video


    public init(
        alternativeVideos: [AlternativeVideo],
        caption: FormattedText,
        cover: Photo?,
        hasSpoiler: Bool,
        isSecret: Bool,
        showCaptionAboveMedia: Bool,
        startTimestamp: Int,
        storyboards: [VideoStoryboard],
        video: Video
    ) {
        self.alternativeVideos = alternativeVideos
        self.caption = caption
        self.cover = cover
        self.hasSpoiler = hasSpoiler
        self.isSecret = isSecret
        self.showCaptionAboveMedia = showCaptionAboveMedia
        self.startTimestamp = startTimestamp
        self.storyboards = storyboards
        self.video = video
    }
}

/// A video note message
public struct MessageVideoNote: Codable, Equatable, Hashable {

    /// True, if the video note thumbnail must be blurred and the video note must be shown only while tapped
    public let isSecret: Bool

    /// True, if at least one of the recipients has viewed the video note
    public let isViewed: Bool

    /// The video note description
    public let videoNote: VideoNote


    public init(
        isSecret: Bool,
        isViewed: Bool,
        videoNote: VideoNote
    ) {
        self.isSecret = isSecret
        self.isViewed = isViewed
        self.videoNote = videoNote
    }
}

/// A voice note message
public struct MessageVoiceNote: Codable, Equatable, Hashable {

    /// Voice note caption
    public let caption: FormattedText

    /// True, if at least one of the recipients has listened to the voice note
    public let isListened: Bool

    /// The voice note description
    public let voiceNote: VoiceNote


    public init(
        caption: FormattedText,
        isListened: Bool,
        voiceNote: VoiceNote
    ) {
        self.caption = caption
        self.isListened = isListened
        self.voiceNote = voiceNote
    }
}

/// A message with a location
public struct MessageLocation: Codable, Equatable, Hashable {

    /// Left time for which the location can be updated, in seconds. If 0, then the location can't be updated anymore. The update updateMessageContent is not sent when this field changes
    public let expiresIn: Int

    /// For live locations, a direction in which the location moves, in degrees; 1-360. If 0 the direction is unknown
    public let heading: Int

    /// Time relative to the message send date, for which the location can be updated, in seconds; if 0x7FFFFFFF, then location can be updated forever
    public let livePeriod: Int

    /// The location description
    public let location: Location

    /// For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). 0 if the notification is disabled. Available only to the message sender
    public let proximityAlertRadius: Int


    public init(
        expiresIn: Int,
        heading: Int,
        livePeriod: Int,
        location: Location,
        proximityAlertRadius: Int
    ) {
        self.expiresIn = expiresIn
        self.heading = heading
        self.livePeriod = livePeriod
        self.location = location
        self.proximityAlertRadius = proximityAlertRadius
    }
}

/// A message with information about a venue
public struct MessageVenue: Codable, Equatable, Hashable {

    /// The venue description
    public let venue: Venue


    public init(venue: Venue) {
        self.venue = venue
    }
}

/// A message with a user contact
public struct MessageContact: Codable, Equatable, Hashable {

    /// The contact description
    public let contact: Contact


    public init(contact: Contact) {
        self.contact = contact
    }
}

/// A message with an animated emoji
public struct MessageAnimatedEmoji: Codable, Equatable, Hashable {

    /// The animated emoji
    public let animatedEmoji: AnimatedEmoji

    /// The corresponding emoji
    public let emoji: String


    public init(
        animatedEmoji: AnimatedEmoji,
        emoji: String
    ) {
        self.animatedEmoji = animatedEmoji
        self.emoji = emoji
    }
}

/// A dice message. The dice value is randomly generated by the server
public struct MessageDice: Codable, Equatable, Hashable {

    /// Emoji on which the dice throw animation is based
    public let emoji: String

    /// The animated stickers with the final dice animation; may be null if unknown. The update updateMessageContent will be sent when the sticker became known
    public let finalState: DiceStickers?

    /// The animated stickers with the initial dice animation; may be null if unknown. The update updateMessageContent will be sent when the sticker became known
    public let initialState: DiceStickers?

    /// Number of frame after which a success animation like a shower of confetti needs to be shown on updateMessageSendSucceeded
    public let successAnimationFrameNumber: Int

    /// The dice value. If the value is 0, the dice don't have final state yet
    public let value: Int


    public init(
        emoji: String,
        finalState: DiceStickers?,
        initialState: DiceStickers?,
        successAnimationFrameNumber: Int,
        value: Int
    ) {
        self.emoji = emoji
        self.finalState = finalState
        self.initialState = initialState
        self.successAnimationFrameNumber = successAnimationFrameNumber
        self.value = value
    }
}

/// A message with a game
public struct MessageGame: Codable, Equatable, Hashable {

    /// The game description
    public let game: Game


    public init(game: Game) {
        self.game = game
    }
}

/// A message with a poll
public struct MessagePoll: Codable, Equatable, Hashable {

    /// The poll description
    public let poll: Poll


    public init(poll: Poll) {
        self.poll = poll
    }
}

/// A message with a forwarded story
public struct MessageStory: Codable, Equatable, Hashable {

    /// Story identifier
    public let storyId: Int

    /// Identifier of the chat that posted the story
    public let storyPosterChatId: Int64

    /// True, if the story was automatically forwarded because of a mention of the user
    public let viaMention: Bool


    public init(
        storyId: Int,
        storyPosterChatId: Int64,
        viaMention: Bool
    ) {
        self.storyId = storyId
        self.storyPosterChatId = storyPosterChatId
        self.viaMention = viaMention
    }
}

/// A message with a checklist
public struct MessageChecklist: Codable, Equatable, Hashable {

    /// The checklist description
    public let list: Checklist


    public init(list: Checklist) {
        self.list = list
    }
}

/// A message with an invoice from a bot. Use getInternalLink with internalLinkTypeBotStart to share the invoice
public struct MessageInvoice: Codable, Equatable, Hashable {

    /// Currency for the product price
    public let currency: String

    /// True, if the invoice is a test invoice
    public let isTest: Bool

    /// True, if the shipping address must be specified
    public let needShippingAddress: Bool

    /// Extended media attached to the invoice; may be null if none
    public let paidMedia: PaidMedia?

    /// Extended media caption; may be null if none
    public let paidMediaCaption: FormattedText?

    /// Information about the product
    public let productInfo: ProductInfo

    /// The identifier of the message with the receipt, after the product has been purchased
    public let receiptMessageId: Int64

    /// Unique invoice bot start_parameter to be passed to getInternalLink
    public let startParameter: String

    /// Product total price in the smallest units of the currency
    public let totalAmount: Int64


    public init(
        currency: String,
        isTest: Bool,
        needShippingAddress: Bool,
        paidMedia: PaidMedia?,
        paidMediaCaption: FormattedText?,
        productInfo: ProductInfo,
        receiptMessageId: Int64,
        startParameter: String,
        totalAmount: Int64
    ) {
        self.currency = currency
        self.isTest = isTest
        self.needShippingAddress = needShippingAddress
        self.paidMedia = paidMedia
        self.paidMediaCaption = paidMediaCaption
        self.productInfo = productInfo
        self.receiptMessageId = receiptMessageId
        self.startParameter = startParameter
        self.totalAmount = totalAmount
    }
}

/// A message with information about an ended call
public struct MessageCall: Codable, Equatable, Hashable {

    /// Reason why the call was discarded
    public let discardReason: CallDiscardReason

    /// Call duration, in seconds
    public let duration: Int

    /// True, if the call was a video call
    public let isVideo: Bool


    public init(
        discardReason: CallDiscardReason,
        duration: Int,
        isVideo: Bool
    ) {
        self.discardReason = discardReason
        self.duration = duration
        self.isVideo = isVideo
    }
}

/// A message with information about a group call not bound to a chat. If the message is incoming, the call isn't active, isn't missed, and has no duration, and getOption("can_accept_calls") is true, then incoming call screen must be shown to the user. Use getGroupCallParticipants to show current group call participants on the screen. Use joinGroupCall to accept the call or declineGroupCallInvitation to decline it. If the call become active or missed, then the call screen must be hidden
public struct MessageGroupCall: Codable, Equatable, Hashable {

    /// Call duration, in seconds; for left calls only
    public let duration: Int

    /// True, if the call is active, i.e. the called user joined the call
    public let isActive: Bool

    /// True, if the call is a video call
    public let isVideo: Bool

    /// Identifiers of some other call participants
    public let otherParticipantIds: [MessageSender]

    /// True, if the called user missed or declined the call
    public let wasMissed: Bool


    public init(
        duration: Int,
        isActive: Bool,
        isVideo: Bool,
        otherParticipantIds: [MessageSender],
        wasMissed: Bool
    ) {
        self.duration = duration
        self.isActive = isActive
        self.isVideo = isVideo
        self.otherParticipantIds = otherParticipantIds
        self.wasMissed = wasMissed
    }
}

/// A new video chat was scheduled
public struct MessageVideoChatScheduled: Codable, Equatable, Hashable {

    /// Identifier of the video chat. The video chat can be received through the method getGroupCall
    public let groupCallId: Int

    /// Point in time (Unix timestamp) when the group call is expected to be started by an administrator
    public let startDate: Int


    public init(
        groupCallId: Int,
        startDate: Int
    ) {
        self.groupCallId = groupCallId
        self.startDate = startDate
    }
}

/// A newly created video chat
public struct MessageVideoChatStarted: Codable, Equatable, Hashable {

    /// Identifier of the video chat. The video chat can be received through the method getGroupCall
    public let groupCallId: Int


    public init(groupCallId: Int) {
        self.groupCallId = groupCallId
    }
}

/// A message with information about an ended video chat
public struct MessageVideoChatEnded: Codable, Equatable, Hashable {

    /// Call duration, in seconds
    public let duration: Int


    public init(duration: Int) {
        self.duration = duration
    }
}

/// A message with information about an invitation to a video chat
public struct MessageInviteVideoChatParticipants: Codable, Equatable, Hashable {

    /// Identifier of the video chat. The video chat can be received through the method getGroupCall
    public let groupCallId: Int

    /// Invited user identifiers
    public let userIds: [Int64]


    public init(
        groupCallId: Int,
        userIds: [Int64]
    ) {
        self.groupCallId = groupCallId
        self.userIds = userIds
    }
}

/// A newly created basic group
public struct MessageBasicGroupChatCreate: Codable, Equatable, Hashable {

    /// User identifiers of members in the basic group
    public let memberUserIds: [Int64]

    /// Title of the basic group
    public let title: String


    public init(
        memberUserIds: [Int64],
        title: String
    ) {
        self.memberUserIds = memberUserIds
        self.title = title
    }
}

/// A newly created supergroup or channel
public struct MessageSupergroupChatCreate: Codable, Equatable, Hashable {

    /// Title of the supergroup or channel
    public let title: String


    public init(title: String) {
        self.title = title
    }
}

/// An updated chat title
public struct MessageChatChangeTitle: Codable, Equatable, Hashable {

    /// New chat title
    public let title: String


    public init(title: String) {
        self.title = title
    }
}

/// An updated chat photo
public struct MessageChatChangePhoto: Codable, Equatable, Hashable {

    /// New chat photo
    public let photo: ChatPhoto


    public init(photo: ChatPhoto) {
        self.photo = photo
    }
}

/// New chat members were added
public struct MessageChatAddMembers: Codable, Equatable, Hashable {

    /// User identifiers of the new members
    public let memberUserIds: [Int64]


    public init(memberUserIds: [Int64]) {
        self.memberUserIds = memberUserIds
    }
}

/// A chat member was deleted
public struct MessageChatDeleteMember: Codable, Equatable, Hashable {

    /// User identifier of the deleted chat member
    public let userId: Int64


    public init(userId: Int64) {
        self.userId = userId
    }
}

/// A basic group was upgraded to a supergroup and was deactivated as the result
public struct MessageChatUpgradeTo: Codable, Equatable, Hashable {

    /// Identifier of the supergroup to which the basic group was upgraded
    public let supergroupId: Int64


    public init(supergroupId: Int64) {
        self.supergroupId = supergroupId
    }
}

/// A supergroup has been created from a basic group
public struct MessageChatUpgradeFrom: Codable, Equatable, Hashable {

    /// The identifier of the original basic group
    public let basicGroupId: Int64

    /// Title of the newly created supergroup
    public let title: String


    public init(
        basicGroupId: Int64,
        title: String
    ) {
        self.basicGroupId = basicGroupId
        self.title = title
    }
}

/// A message has been pinned
public struct MessagePinMessage: Codable, Equatable, Hashable {

    /// Identifier of the pinned message, can be an identifier of a deleted message or 0
    public let messageId: Int64


    public init(messageId: Int64) {
        self.messageId = messageId
    }
}

/// A new background was set in the chat
public struct MessageChatSetBackground: Codable, Equatable, Hashable {

    /// The new background
    public let background: ChatBackground

    /// Identifier of the message with a previously set same background; 0 if none. Can be an identifier of a deleted message
    public let oldBackgroundMessageId: Int64

    /// True, if the background was set only for self
    public let onlyForSelf: Bool


    public init(
        background: ChatBackground,
        oldBackgroundMessageId: Int64,
        onlyForSelf: Bool
    ) {
        self.background = background
        self.oldBackgroundMessageId = oldBackgroundMessageId
        self.onlyForSelf = onlyForSelf
    }
}

/// A theme in the chat has been changed
public struct MessageChatSetTheme: Codable, Equatable, Hashable {

    /// If non-empty, name of a new theme, set for the chat. Otherwise, chat theme was reset to the default one
    public let themeName: String


    public init(themeName: String) {
        self.themeName = themeName
    }
}

/// The auto-delete or self-destruct timer for messages in the chat has been changed
public struct MessageChatSetMessageAutoDeleteTime: Codable, Equatable, Hashable {

    /// If not 0, a user identifier, which default setting was automatically applied
    public let fromUserId: Int64

    /// New value auto-delete or self-destruct time, in seconds; 0 if disabled
    public let messageAutoDeleteTime: Int


    public init(
        fromUserId: Int64,
        messageAutoDeleteTime: Int
    ) {
        self.fromUserId = fromUserId
        self.messageAutoDeleteTime = messageAutoDeleteTime
    }
}

/// The chat was boosted by the sender of the message
public struct MessageChatBoost: Codable, Equatable, Hashable {

    /// Number of times the chat was boosted
    public let boostCount: Int


    public init(boostCount: Int) {
        self.boostCount = boostCount
    }
}

/// A forum topic has been created
public struct MessageForumTopicCreated: Codable, Equatable, Hashable {

    /// Icon of the topic
    public let icon: ForumTopicIcon

    /// Name of the topic
    public let name: String


    public init(
        icon: ForumTopicIcon,
        name: String
    ) {
        self.icon = icon
        self.name = name
    }
}

/// A forum topic has been edited
public struct MessageForumTopicEdited: Codable, Equatable, Hashable {

    /// True, if icon's custom_emoji_id is changed
    public let editIconCustomEmojiId: Bool

    /// New unique identifier of the custom emoji shown on the topic icon; 0 if none. Must be ignored if edit_icon_custom_emoji_id is false
    public let iconCustomEmojiId: TdInt64

    /// If non-empty, the new name of the topic
    public let name: String


    public init(
        editIconCustomEmojiId: Bool,
        iconCustomEmojiId: TdInt64,
        name: String
    ) {
        self.editIconCustomEmojiId = editIconCustomEmojiId
        self.iconCustomEmojiId = iconCustomEmojiId
        self.name = name
    }
}

/// A forum topic has been closed or opened
public struct MessageForumTopicIsClosedToggled: Codable, Equatable, Hashable {

    /// True, if the topic was closed; otherwise, the topic was reopened
    public let isClosed: Bool


    public init(isClosed: Bool) {
        self.isClosed = isClosed
    }
}

/// A General forum topic has been hidden or unhidden
public struct MessageForumTopicIsHiddenToggled: Codable, Equatable, Hashable {

    /// True, if the topic was hidden; otherwise, the topic was unhidden
    public let isHidden: Bool


    public init(isHidden: Bool) {
        self.isHidden = isHidden
    }
}

/// A profile photo was suggested to a user in a private chat
public struct MessageSuggestProfilePhoto: Codable, Equatable, Hashable {

    /// The suggested chat photo. Use the method setProfilePhoto with inputChatPhotoPrevious to apply the photo
    public let photo: ChatPhoto


    public init(photo: ChatPhoto) {
        self.photo = photo
    }
}

/// A non-standard action has happened in the chat
public struct MessageCustomServiceAction: Codable, Equatable, Hashable {

    /// Message text to be shown in the chat
    public let text: String


    public init(text: String) {
        self.text = text
    }
}

/// A new high score was achieved in a game
public struct MessageGameScore: Codable, Equatable, Hashable {

    /// Identifier of the game; may be different from the games presented in the message with the game
    public let gameId: TdInt64

    /// Identifier of the message with the game, can be an identifier of a deleted message
    public let gameMessageId: Int64

    /// New score
    public let score: Int


    public init(
        gameId: TdInt64,
        gameMessageId: Int64,
        score: Int
    ) {
        self.gameId = gameId
        self.gameMessageId = gameMessageId
        self.score = score
    }
}

/// A payment has been sent to a bot or a business account
public struct MessagePaymentSuccessful: Codable, Equatable, Hashable {

    /// Currency for the price of the product
    public let currency: String

    /// Identifier of the chat, containing the corresponding invoice message
    public let invoiceChatId: Int64

    /// Identifier of the message with the corresponding invoice; can be 0 or an identifier of a deleted message
    public let invoiceMessageId: Int64

    /// Name of the invoice; may be empty if unknown
    public let invoiceName: String

    /// True, if this is the first recurring payment
    public let isFirstRecurring: Bool

    /// True, if this is a recurring payment
    public let isRecurring: Bool

    /// Point in time (Unix timestamp) when the subscription will expire; 0 if unknown or the payment isn't recurring
    public let subscriptionUntilDate: Int

    /// Total price for the product, in the smallest units of the currency
    public let totalAmount: Int64


    public init(
        currency: String,
        invoiceChatId: Int64,
        invoiceMessageId: Int64,
        invoiceName: String,
        isFirstRecurring: Bool,
        isRecurring: Bool,
        subscriptionUntilDate: Int,
        totalAmount: Int64
    ) {
        self.currency = currency
        self.invoiceChatId = invoiceChatId
        self.invoiceMessageId = invoiceMessageId
        self.invoiceName = invoiceName
        self.isFirstRecurring = isFirstRecurring
        self.isRecurring = isRecurring
        self.subscriptionUntilDate = subscriptionUntilDate
        self.totalAmount = totalAmount
    }
}

/// A payment has been received by the bot or the business account
public struct MessagePaymentSuccessfulBot: Codable, Equatable, Hashable {

    /// Currency for price of the product
    public let currency: String

    /// Invoice payload
    public let invoicePayload: Data

    /// True, if this is the first recurring payment
    public let isFirstRecurring: Bool

    /// True, if this is a recurring payment
    public let isRecurring: Bool

    /// Information about the order; may be null; for bots only
    public let orderInfo: OrderInfo?

    /// Provider payment identifier
    public let providerPaymentChargeId: String

    /// Identifier of the shipping option chosen by the user; may be empty if not applicable; for bots only
    public let shippingOptionId: String

    /// Point in time (Unix timestamp) when the subscription will expire; 0 if unknown or the payment isn't recurring
    public let subscriptionUntilDate: Int

    /// Telegram payment identifier
    public let telegramPaymentChargeId: String

    /// Total price for the product, in the smallest units of the currency
    public let totalAmount: Int64


    public init(
        currency: String,
        invoicePayload: Data,
        isFirstRecurring: Bool,
        isRecurring: Bool,
        orderInfo: OrderInfo?,
        providerPaymentChargeId: String,
        shippingOptionId: String,
        subscriptionUntilDate: Int,
        telegramPaymentChargeId: String,
        totalAmount: Int64
    ) {
        self.currency = currency
        self.invoicePayload = invoicePayload
        self.isFirstRecurring = isFirstRecurring
        self.isRecurring = isRecurring
        self.orderInfo = orderInfo
        self.providerPaymentChargeId = providerPaymentChargeId
        self.shippingOptionId = shippingOptionId
        self.subscriptionUntilDate = subscriptionUntilDate
        self.telegramPaymentChargeId = telegramPaymentChargeId
        self.totalAmount = totalAmount
    }
}

/// A payment has been refunded
public struct MessagePaymentRefunded: Codable, Equatable, Hashable {

    /// Currency for the price of the product
    public let currency: String

    /// Invoice payload; only for bots
    public let invoicePayload: Data

    /// Identifier of the previous owner of the Telegram Stars that refunds them
    public let ownerId: MessageSender

    /// Provider payment identifier
    public let providerPaymentChargeId: String

    /// Telegram payment identifier
    public let telegramPaymentChargeId: String

    /// Total price for the product, in the smallest units of the currency
    public let totalAmount: Int64


    public init(
        currency: String,
        invoicePayload: Data,
        ownerId: MessageSender,
        providerPaymentChargeId: String,
        telegramPaymentChargeId: String,
        totalAmount: Int64
    ) {
        self.currency = currency
        self.invoicePayload = invoicePayload
        self.ownerId = ownerId
        self.providerPaymentChargeId = providerPaymentChargeId
        self.telegramPaymentChargeId = telegramPaymentChargeId
        self.totalAmount = totalAmount
    }
}

/// Telegram Premium was gifted to a user
public struct MessageGiftedPremium: Codable, Equatable, Hashable {

    /// The paid amount, in the smallest units of the currency
    public let amount: Int64

    /// Cryptocurrency used to pay for the gift; may be empty if none
    public let cryptocurrency: String

    /// The paid amount, in the smallest units of the cryptocurrency; 0 if none
    public let cryptocurrencyAmount: TdInt64

    /// Currency for the paid amount
    public let currency: String

    /// The identifier of a user that gifted Telegram Premium; 0 if the gift was anonymous or is outgoing
    public let gifterUserId: Int64

    /// Number of months the Telegram Premium subscription will be active
    public let monthCount: Int

    /// The identifier of a user that received Telegram Premium; 0 if the gift is incoming
    public let receiverUserId: Int64

    /// A sticker to be shown in the message; may be null if unknown
    public let sticker: Sticker?

    /// Message added to the gifted Telegram Premium by the sender
    public let text: FormattedText


    public init(
        amount: Int64,
        cryptocurrency: String,
        cryptocurrencyAmount: TdInt64,
        currency: String,
        gifterUserId: Int64,
        monthCount: Int,
        receiverUserId: Int64,
        sticker: Sticker?,
        text: FormattedText
    ) {
        self.amount = amount
        self.cryptocurrency = cryptocurrency
        self.cryptocurrencyAmount = cryptocurrencyAmount
        self.currency = currency
        self.gifterUserId = gifterUserId
        self.monthCount = monthCount
        self.receiverUserId = receiverUserId
        self.sticker = sticker
        self.text = text
    }
}

/// A Telegram Premium gift code was created for the user
public struct MessagePremiumGiftCode: Codable, Equatable, Hashable {

    /// The paid amount, in the smallest units of the currency; 0 if unknown
    public let amount: Int64

    /// The gift code
    public let code: String

    /// Identifier of a chat or a user that created the gift code; may be null if unknown
    public let creatorId: MessageSender?

    /// Cryptocurrency used to pay for the gift; may be empty if none or unknown
    public let cryptocurrency: String

    /// The paid amount, in the smallest units of the cryptocurrency; 0 if unknown
    public let cryptocurrencyAmount: TdInt64

    /// Currency for the paid amount; empty if unknown
    public let currency: String

    /// True, if the gift code was created for a giveaway
    public let isFromGiveaway: Bool

    /// True, if the winner for the corresponding Telegram Premium subscription wasn't chosen
    public let isUnclaimed: Bool

    /// Number of months the Telegram Premium subscription will be active after code activation
    public let monthCount: Int

    /// A sticker to be shown in the message; may be null if unknown
    public let sticker: Sticker?

    /// Message added to the gift
    public let text: FormattedText


    public init(
        amount: Int64,
        code: String,
        creatorId: MessageSender?,
        cryptocurrency: String,
        cryptocurrencyAmount: TdInt64,
        currency: String,
        isFromGiveaway: Bool,
        isUnclaimed: Bool,
        monthCount: Int,
        sticker: Sticker?,
        text: FormattedText
    ) {
        self.amount = amount
        self.code = code
        self.creatorId = creatorId
        self.cryptocurrency = cryptocurrency
        self.cryptocurrencyAmount = cryptocurrencyAmount
        self.currency = currency
        self.isFromGiveaway = isFromGiveaway
        self.isUnclaimed = isUnclaimed
        self.monthCount = monthCount
        self.sticker = sticker
        self.text = text
    }
}

/// A giveaway was created for the chat. Use telegramPaymentPurposePremiumGiveaway, storePaymentPurposePremiumGiveaway, telegramPaymentPurposeStarGiveaway, or storePaymentPurposeStarGiveaway to create a giveaway
public struct MessageGiveawayCreated: Codable, Equatable, Hashable {

    /// Number of Telegram Stars that will be shared by winners of the giveaway; 0 for Telegram Premium giveaways
    public let starCount: Int64


    public init(starCount: Int64) {
        self.starCount = starCount
    }
}

/// A giveaway
public struct MessageGiveaway: Codable, Equatable, Hashable {

    /// Giveaway parameters
    public let parameters: GiveawayParameters

    /// Prize of the giveaway
    public let prize: GiveawayPrize

    /// A sticker to be shown in the message; may be null if unknown
    public let sticker: Sticker?

    /// Number of users which will receive Telegram Premium subscription gift codes
    public let winnerCount: Int


    public init(
        parameters: GiveawayParameters,
        prize: GiveawayPrize,
        sticker: Sticker?,
        winnerCount: Int
    ) {
        self.parameters = parameters
        self.prize = prize
        self.sticker = sticker
        self.winnerCount = winnerCount
    }
}

/// A giveaway without public winners has been completed for the chat
public struct MessageGiveawayCompleted: Codable, Equatable, Hashable {

    /// Identifier of the message with the giveaway; can be 0 if the message was deleted
    public let giveawayMessageId: Int64

    /// True, if the giveaway is a Telegram Star giveaway
    public let isStarGiveaway: Bool

    /// Number of undistributed prizes; for Telegram Premium giveaways only
    public let unclaimedPrizeCount: Int

    /// Number of winners in the giveaway
    public let winnerCount: Int


    public init(
        giveawayMessageId: Int64,
        isStarGiveaway: Bool,
        unclaimedPrizeCount: Int,
        winnerCount: Int
    ) {
        self.giveawayMessageId = giveawayMessageId
        self.isStarGiveaway = isStarGiveaway
        self.unclaimedPrizeCount = unclaimedPrizeCount
        self.winnerCount = winnerCount
    }
}

/// A giveaway with public winners has been completed for the chat
public struct MessageGiveawayWinners: Codable, Equatable, Hashable {

    /// Point in time (Unix timestamp) when the winners were selected. May be bigger than winners selection date specified in parameters of the giveaway
    public let actualWinnersSelectionDate: Int

    /// Number of other chats that participated in the giveaway
    public let additionalChatCount: Int

    /// Identifier of the supergroup or channel chat, which was automatically boosted by the winners of the giveaway
    public let boostedChatId: Int64

    /// Identifier of the message with the giveaway in the boosted chat
    public let giveawayMessageId: Int64

    /// True, if only new members of the chats were eligible for the giveaway
    public let onlyNewMembers: Bool

    /// Prize of the giveaway
    public let prize: GiveawayPrize

    /// Additional description of the giveaway prize
    public let prizeDescription: String

    /// Number of undistributed prizes; for Telegram Premium giveaways only
    public let unclaimedPrizeCount: Int

    /// True, if the giveaway was canceled and was fully refunded
    public let wasRefunded: Bool

    /// Total number of winners in the giveaway
    public let winnerCount: Int

    /// Up to 100 user identifiers of the winners of the giveaway
    public let winnerUserIds: [Int64]


    public init(
        actualWinnersSelectionDate: Int,
        additionalChatCount: Int,
        boostedChatId: Int64,
        giveawayMessageId: Int64,
        onlyNewMembers: Bool,
        prize: GiveawayPrize,
        prizeDescription: String,
        unclaimedPrizeCount: Int,
        wasRefunded: Bool,
        winnerCount: Int,
        winnerUserIds: [Int64]
    ) {
        self.actualWinnersSelectionDate = actualWinnersSelectionDate
        self.additionalChatCount = additionalChatCount
        self.boostedChatId = boostedChatId
        self.giveawayMessageId = giveawayMessageId
        self.onlyNewMembers = onlyNewMembers
        self.prize = prize
        self.prizeDescription = prizeDescription
        self.unclaimedPrizeCount = unclaimedPrizeCount
        self.wasRefunded = wasRefunded
        self.winnerCount = winnerCount
        self.winnerUserIds = winnerUserIds
    }
}

/// Telegram Stars were gifted to a user
public struct MessageGiftedStars: Codable, Equatable, Hashable {

    /// The paid amount, in the smallest units of the currency
    public let amount: Int64

    /// Cryptocurrency used to pay for the gift; may be empty if none
    public let cryptocurrency: String

    /// The paid amount, in the smallest units of the cryptocurrency; 0 if none
    public let cryptocurrencyAmount: TdInt64

    /// Currency for the paid amount
    public let currency: String

    /// The identifier of a user that gifted Telegram Stars; 0 if the gift was anonymous or is outgoing
    public let gifterUserId: Int64

    /// The identifier of a user that received Telegram Stars; 0 if the gift is incoming
    public let receiverUserId: Int64

    /// Number of Telegram Stars that were gifted
    public let starCount: Int64

    /// A sticker to be shown in the message; may be null if unknown
    public let sticker: Sticker?

    /// Identifier of the transaction for Telegram Stars purchase; for receiver only
    public let transactionId: String


    public init(
        amount: Int64,
        cryptocurrency: String,
        cryptocurrencyAmount: TdInt64,
        currency: String,
        gifterUserId: Int64,
        receiverUserId: Int64,
        starCount: Int64,
        sticker: Sticker?,
        transactionId: String
    ) {
        self.amount = amount
        self.cryptocurrency = cryptocurrency
        self.cryptocurrencyAmount = cryptocurrencyAmount
        self.currency = currency
        self.gifterUserId = gifterUserId
        self.receiverUserId = receiverUserId
        self.starCount = starCount
        self.sticker = sticker
        self.transactionId = transactionId
    }
}

/// Toncoins were gifted to a user
public struct MessageGiftedTon: Codable, Equatable, Hashable {

    /// The identifier of a user that gifted Toncoins; 0 if the gift was anonymous or is outgoing
    public let gifterUserId: Int64

    /// The identifier of a user that received Toncoins; 0 if the gift is incoming
    public let receiverUserId: Int64

    /// A sticker to be shown in the message; may be null if unknown
    public let sticker: Sticker?

    /// The received amount of Toncoins, in the smallest units of the cryptocurrency
    public let tonAmount: Int64

    /// Identifier of the transaction for Toncoin credit; for receiver only
    public let transactionId: String


    public init(
        gifterUserId: Int64,
        receiverUserId: Int64,
        sticker: Sticker?,
        tonAmount: Int64,
        transactionId: String
    ) {
        self.gifterUserId = gifterUserId
        self.receiverUserId = receiverUserId
        self.sticker = sticker
        self.tonAmount = tonAmount
        self.transactionId = transactionId
    }
}

/// A Telegram Stars were received by the current user from a giveaway
public struct MessageGiveawayPrizeStars: Codable, Equatable, Hashable {

    /// Identifier of the supergroup or channel chat, which was automatically boosted by the winners of the giveaway
    public let boostedChatId: Int64

    /// Identifier of the message with the giveaway in the boosted chat; can be 0 if the message was deleted
    public let giveawayMessageId: Int64

    /// True, if the corresponding winner wasn't chosen and the Telegram Stars were received by the owner of the boosted chat
    public let isUnclaimed: Bool

    /// Number of Telegram Stars that were received
    public let starCount: Int64

    /// A sticker to be shown in the message; may be null if unknown
    public let sticker: Sticker?

    /// Identifier of the transaction for Telegram Stars credit
    public let transactionId: String


    public init(
        boostedChatId: Int64,
        giveawayMessageId: Int64,
        isUnclaimed: Bool,
        starCount: Int64,
        sticker: Sticker?,
        transactionId: String
    ) {
        self.boostedChatId = boostedChatId
        self.giveawayMessageId = giveawayMessageId
        self.isUnclaimed = isUnclaimed
        self.starCount = starCount
        self.sticker = sticker
        self.transactionId = transactionId
    }
}

/// A regular gift was received or sent by the current user, or the current user was notified about a channel gift
public struct MessageGift: Codable, Equatable, Hashable {

    /// True, if the gift can be upgraded to a unique gift; only for the receiver of the gift
    public let canBeUpgraded: Bool

    /// The gift
    public let gift: Gift

    /// True, if the sender and gift text are shown only to the gift receiver; otherwise, everyone will be able to see them
    public let isPrivate: Bool

    /// True, if the gift is displayed on the user's or the channel's profile page; only for the receiver of the gift
    public let isSaved: Bool

    /// Number of Telegram Stars that were paid by the sender for the ability to upgrade the gift
    public let prepaidUpgradeStarCount: Int64

    /// Unique identifier of the received gift for the current user; only for the receiver of the gift
    public let receivedGiftId: String

    /// Receiver of the gift
    public let receiverId: MessageSender

    /// Number of Telegram Stars that can be claimed by the receiver instead of the regular gift; 0 if the gift can't be sold by the receiver
    public let sellStarCount: Int64

    /// Sender of the gift
    public let senderId: MessageSender

    /// Message added to the gift
    public let text: FormattedText

    /// Identifier of the corresponding upgraded gift; may be empty if unknown. Use getReceivedGift to get information about the gift
    public let upgradedReceivedGiftId: String

    /// True, if the gift was converted to Telegram Stars; only for the receiver of the gift
    public let wasConverted: Bool

    /// True, if the gift was refunded and isn't available anymore
    public let wasRefunded: Bool

    /// True, if the gift was upgraded to a unique gift
    public let wasUpgraded: Bool


    public init(
        canBeUpgraded: Bool,
        gift: Gift,
        isPrivate: Bool,
        isSaved: Bool,
        prepaidUpgradeStarCount: Int64,
        receivedGiftId: String,
        receiverId: MessageSender,
        sellStarCount: Int64,
        senderId: MessageSender,
        text: FormattedText,
        upgradedReceivedGiftId: String,
        wasConverted: Bool,
        wasRefunded: Bool,
        wasUpgraded: Bool
    ) {
        self.canBeUpgraded = canBeUpgraded
        self.gift = gift
        self.isPrivate = isPrivate
        self.isSaved = isSaved
        self.prepaidUpgradeStarCount = prepaidUpgradeStarCount
        self.receivedGiftId = receivedGiftId
        self.receiverId = receiverId
        self.sellStarCount = sellStarCount
        self.senderId = senderId
        self.text = text
        self.upgradedReceivedGiftId = upgradedReceivedGiftId
        self.wasConverted = wasConverted
        self.wasRefunded = wasRefunded
        self.wasUpgraded = wasUpgraded
    }
}

/// An upgraded gift was received or sent by the current user, or the current user was notified about a channel gift
public struct MessageUpgradedGift: Codable, Equatable, Hashable {

    /// True, if the gift can be transferred to another owner; only for the receiver of the gift
    public let canBeTransferred: Bool

    /// Point in time (Unix timestamp) when the gift can be transferred to the TON blockchain as an NFT; 0 if NFT export isn't possible; only for the receiver of the gift
    public let exportDate: Int

    /// The gift
    public let gift: UpgradedGift

    /// True, if the gift is displayed on the user's or the channel's profile page; only for the receiver of the gift
    public let isSaved: Bool

    /// Point in time (Unix timestamp) when the gift can be resold to another user; 0 if the gift can't be resold; only for the receiver of the gift
    public let nextResaleDate: Int

    /// Point in time (Unix timestamp) when the gift can be transferred to another owner; 0 if the gift can be transferred immediately or transfer isn't possible; only for the receiver of the gift
    public let nextTransferDate: Int

    /// Origin of the upgraded gift
    public let origin: UpgradedGiftOrigin

    /// Unique identifier of the received gift for the current user; only for the receiver of the gift
    public let receivedGiftId: String

    /// Receiver of the gift
    public let receiverId: MessageSender

    /// Sender of the gift; may be null for anonymous gifts
    public let senderId: MessageSender?

    /// Number of Telegram Stars that must be paid to transfer the upgraded gift; only for the receiver of the gift
    public let transferStarCount: Int64

    /// True, if the gift has already been transferred to another owner; only for the receiver of the gift
    public let wasTransferred: Bool


    public init(
        canBeTransferred: Bool,
        exportDate: Int,
        gift: UpgradedGift,
        isSaved: Bool,
        nextResaleDate: Int,
        nextTransferDate: Int,
        origin: UpgradedGiftOrigin,
        receivedGiftId: String,
        receiverId: MessageSender,
        senderId: MessageSender?,
        transferStarCount: Int64,
        wasTransferred: Bool
    ) {
        self.canBeTransferred = canBeTransferred
        self.exportDate = exportDate
        self.gift = gift
        self.isSaved = isSaved
        self.nextResaleDate = nextResaleDate
        self.nextTransferDate = nextTransferDate
        self.origin = origin
        self.receivedGiftId = receivedGiftId
        self.receiverId = receiverId
        self.senderId = senderId
        self.transferStarCount = transferStarCount
        self.wasTransferred = wasTransferred
    }
}

/// A gift which purchase, upgrade or transfer were refunded
public struct MessageRefundedUpgradedGift: Codable, Equatable, Hashable {

    /// The gift
    public let gift: Gift

    /// True, if the gift was obtained by upgrading of a previously received gift; otherwise, this is a transferred or resold gift
    public let isUpgrade: Bool

    /// Receiver of the gift
    public let receiverId: MessageSender

    /// Sender of the gift
    public let senderId: MessageSender


    public init(
        gift: Gift,
        isUpgrade: Bool,
        receiverId: MessageSender,
        senderId: MessageSender
    ) {
        self.gift = gift
        self.isUpgrade = isUpgrade
        self.receiverId = receiverId
        self.senderId = senderId
    }
}

/// Paid messages were refunded
public struct MessagePaidMessagesRefunded: Codable, Equatable, Hashable {

    /// The number of refunded messages
    public let messageCount: Int

    /// The number of refunded Telegram Stars
    public let starCount: Int64


    public init(
        messageCount: Int,
        starCount: Int64
    ) {
        self.messageCount = messageCount
        self.starCount = starCount
    }
}

/// A price for paid messages was changed in the supergroup chat
public struct MessagePaidMessagePriceChanged: Codable, Equatable, Hashable {

    /// The new number of Telegram Stars that must be paid by non-administrator users of the supergroup chat for each sent message
    public let paidMessageStarCount: Int64


    public init(paidMessageStarCount: Int64) {
        self.paidMessageStarCount = paidMessageStarCount
    }
}

/// A price for direct messages was changed in the channel chat
public struct MessageDirectMessagePriceChanged: Codable, Equatable, Hashable {

    /// True, if direct messages group was enabled for the channel; false otherwise
    public let isEnabled: Bool

    /// The new number of Telegram Stars that must be paid by non-administrator users of the channel chat for each message sent to the direct messages group; 0 if the direct messages group was disabled or the messages are free
    public let paidMessageStarCount: Int64


    public init(
        isEnabled: Bool,
        paidMessageStarCount: Int64
    ) {
        self.isEnabled = isEnabled
        self.paidMessageStarCount = paidMessageStarCount
    }
}

/// Some tasks from a checklist were marked as done or not done
public struct MessageChecklistTasksDone: Codable, Equatable, Hashable {

    /// Identifier of the message with the checklist; can be 0 if the message was deleted
    public let checklistMessageId: Int64

    /// Identifiers of tasks that were marked as done
    public let markedAsDoneTaskIds: [Int]

    /// Identifiers of tasks that were marked as not done
    public let markedAsNotDoneTaskIds: [Int]


    public init(
        checklistMessageId: Int64,
        markedAsDoneTaskIds: [Int],
        markedAsNotDoneTaskIds: [Int]
    ) {
        self.checklistMessageId = checklistMessageId
        self.markedAsDoneTaskIds = markedAsDoneTaskIds
        self.markedAsNotDoneTaskIds = markedAsNotDoneTaskIds
    }
}

/// Some tasks were added to a checklist
public struct MessageChecklistTasksAdded: Codable, Equatable, Hashable {

    /// Identifier of the message with the checklist; can be 0 if the message was deleted
    public let checklistMessageId: Int64

    /// List of tasks added to the checklist
    public let tasks: [ChecklistTask]


    public init(
        checklistMessageId: Int64,
        tasks: [ChecklistTask]
    ) {
        self.checklistMessageId = checklistMessageId
        self.tasks = tasks
    }
}

/// Approval of suggested post has failed, because the user which proposed the post had no enough funds
public struct MessageSuggestedPostApprovalFailed: Codable, Equatable, Hashable {

    /// Price of the suggested post
    public let price: SuggestedPostPrice

    /// Identifier of the message with the suggested post; can be 0 if the message was deleted
    public let suggestedPostMessageId: Int64


    public init(
        price: SuggestedPostPrice,
        suggestedPostMessageId: Int64
    ) {
        self.price = price
        self.suggestedPostMessageId = suggestedPostMessageId
    }
}

/// A suggested post was approved
public struct MessageSuggestedPostApproved: Codable, Equatable, Hashable {

    /// Price of the suggested post; may be null if the post is non-paid
    public let price: SuggestedPostPrice?

    /// Point in time (Unix timestamp) when the post is expected to be published
    public let sendDate: Int

    /// Identifier of the message with the suggested post; can be 0 if the message was deleted
    public let suggestedPostMessageId: Int64


    public init(
        price: SuggestedPostPrice?,
        sendDate: Int,
        suggestedPostMessageId: Int64
    ) {
        self.price = price
        self.sendDate = sendDate
        self.suggestedPostMessageId = suggestedPostMessageId
    }
}

/// A suggested post was declined
public struct MessageSuggestedPostDeclined: Codable, Equatable, Hashable {

    /// Comment added by administrator of the channel when the post was declined
    public let comment: String

    /// Identifier of the message with the suggested post; can be 0 if the message was deleted
    public let suggestedPostMessageId: Int64


    public init(
        comment: String,
        suggestedPostMessageId: Int64
    ) {
        self.comment = comment
        self.suggestedPostMessageId = suggestedPostMessageId
    }
}

/// A suggested post was published for getOption("suggested_post_lifetime_min") seconds and payment for the post was received
public struct MessageSuggestedPostPaid: Codable, Equatable, Hashable {

    /// The amount of received Telegram Stars
    public let starAmount: StarAmount

    /// Identifier of the message with the suggested post; can be 0 if the message was deleted
    public let suggestedPostMessageId: Int64

    /// The amount of received Toncoins; in the smallest units of the cryptocurrency
    public let tonAmount: Int64


    public init(
        starAmount: StarAmount,
        suggestedPostMessageId: Int64,
        tonAmount: Int64
    ) {
        self.starAmount = starAmount
        self.suggestedPostMessageId = suggestedPostMessageId
        self.tonAmount = tonAmount
    }
}

/// A suggested post was refunded
public struct MessageSuggestedPostRefunded: Codable, Equatable, Hashable {

    /// Reason of the refund
    public let reason: SuggestedPostRefundReason

    /// Identifier of the message with the suggested post; can be 0 if the message was deleted
    public let suggestedPostMessageId: Int64


    public init(
        reason: SuggestedPostRefundReason,
        suggestedPostMessageId: Int64
    ) {
        self.reason = reason
        self.suggestedPostMessageId = suggestedPostMessageId
    }
}

/// The current user shared users, which were requested by the bot
public struct MessageUsersShared: Codable, Equatable, Hashable {

    /// Identifier of the keyboard button with the request
    public let buttonId: Int

    /// The shared users
    public let users: [SharedUser]


    public init(
        buttonId: Int,
        users: [SharedUser]
    ) {
        self.buttonId = buttonId
        self.users = users
    }
}

/// The current user shared a chat, which was requested by the bot
public struct MessageChatShared: Codable, Equatable, Hashable {

    /// Identifier of the keyboard button with the request
    public let buttonId: Int

    /// The shared chat
    public let chat: SharedChat


    public init(
        buttonId: Int,
        chat: SharedChat
    ) {
        self.buttonId = buttonId
        self.chat = chat
    }
}

/// The user allowed the bot to send messages
public struct MessageBotWriteAccessAllowed: Codable, Equatable, Hashable {

    /// The reason why the bot was allowed to write messages
    public let reason: BotWriteAccessAllowReason


    public init(reason: BotWriteAccessAllowReason) {
        self.reason = reason
    }
}

/// Data from a Web App has been sent to a bot
public struct MessageWebAppDataSent: Codable, Equatable, Hashable {

    /// Text of the keyboardButtonTypeWebApp button, which opened the Web App
    public let buttonText: String


    public init(buttonText: String) {
        self.buttonText = buttonText
    }
}

/// Data from a Web App has been received; for bots only
public struct MessageWebAppDataReceived: Codable, Equatable, Hashable {

    /// Text of the keyboardButtonTypeWebApp button, which opened the Web App
    public let buttonText: String

    /// The data
    public let data: String


    public init(
        buttonText: String,
        data: String
    ) {
        self.buttonText = buttonText
        self.data = data
    }
}

/// Telegram Passport data has been sent to a bot
public struct MessagePassportDataSent: Codable, Equatable, Hashable {

    /// List of Telegram Passport element types sent
    public let types: [PassportElementType]


    public init(types: [PassportElementType]) {
        self.types = types
    }
}

/// Telegram Passport data has been received; for bots only
public struct MessagePassportDataReceived: Codable, Equatable, Hashable {

    /// Encrypted data credentials
    public let credentials: EncryptedCredentials

    /// List of received Telegram Passport elements
    public let elements: [EncryptedPassportElement]


    public init(
        credentials: EncryptedCredentials,
        elements: [EncryptedPassportElement]
    ) {
        self.credentials = credentials
        self.elements = elements
    }
}

/// A user in the chat came within proximity alert range
public struct MessageProximityAlertTriggered: Codable, Equatable, Hashable {

    /// The distance between the users
    public let distance: Int

    /// The identifier of a user or chat that triggered the proximity alert
    public let travelerId: MessageSender

    /// The identifier of a user or chat that subscribed for the proximity alert
    public let watcherId: MessageSender


    public init(
        distance: Int,
        travelerId: MessageSender,
        watcherId: MessageSender
    ) {
        self.distance = distance
        self.travelerId = travelerId
        self.watcherId = watcherId
    }
}

